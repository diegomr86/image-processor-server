{"version":3,"sources":["../../src/pages/plants/plants.module.ts","../../node_modules/ionic-image-loader/dist/providers/image-loader-config.js","../../node_modules/ionic-image-loader/dist/providers/image-loader.js","../../node_modules/ionic-image-loader/dist/components/img-loader.js","../../node_modules/ionic-image-loader/dist/index.js","../../node_modules/ionic-image-loader/dist/image-loader.module.js","../../node_modules/rxjs/add/operator/first.js","../../node_modules/rxjs/operator/first.js","../../src/pages/plants/plants.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAyC;AACa;AACN;AACM;AACgB;AAEhC;AAgBtC;IAAA;IAAgC,CAAC;IAApB,gBAAgB;QAd5B,uEAAQ,CAAC;YACR,YAAY,EAAE;gBACZ,2DAAU;aACX;YACD,OAAO,EAAE;gBACP,sEAAe,CAAC,QAAQ,CAAC,2DAAU,CAAC;gBACpC,4EAAe,CAAC,QAAQ,EAAE;gBAC1B,4EAAgB;gBAChB,uFAAgB;aACjB;YACD,OAAO,EAAE;gBACP,2DAAU;aACX;SACF,CAAC;OACW,gBAAgB,CAAI;IAAD,uBAAC;CAAA;AAAJ;;;;;;;;;ACtB7B;AAAA;AAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO,iBAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA,CAAC;AAC4B;AAC7B;AACA,KAAK,OAAO,iEAAU,EAAE;AACxB;AACA;AACA,gDAAgD,WAAW;AAC3D,+C;;;;;;;;AC3LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2C;AACD;AACQ;AACK;AACG;AACb;AACZ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,mBAAmB,gEAAI;AACvB,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB,OAAO;AAC/B,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gBAAgB,EAAE;AAC9D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,oEAAoE,gBAAgB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,+BAA+B,2BAA2B,EAAE;AAC5D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA,uDAAuD,0CAA0C,EAAE;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,oCAAoC,iEAAiE,EAAE;AACvG;AACA;AACA,sEAAsE,mCAAmC,EAAE;AAC3G;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB,EAAE;AAC9D,4CAA4C,iBAAiB,EAAE,EAAE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2EAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,+BAA+B;AAC/B,SAAS;AACT;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC,iBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gGAAgG,EAAE;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+FAA+F,EAAE;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,CAAC;AACsB;AACvB;AACA,KAAK,OAAO,iEAAU,EAAE;AACxB;AACA;AACA,0CAA0C;AAC1C,KAAK,OAAO,+EAAiB,GAAG;AAChC,KAAK,OAAO,gEAAI,GAAG;AACnB,KAAK,OAAO,wEAAU,GAAG;AACzB,KAAK,OAAO,+DAAQ,GAAG;AACvB,EAAE;AACF,wC;;;;;;;;AChlBA;AAAA;AAAA;AAAA;AAA6F;AACrC;AACa;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mEAAY;AACpC;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iCAAiC,EAAE;AAC1E,qCAAqC,sDAAsD,EAAE;AAC7F;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA,qCAAqC,oBAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,qFAAqF,EAAE;AACjK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACoB;AACrB;AACA,KAAK,OAAO,gEAAS;AACrB;AACA;AACA;AACA,uCAAuC,aAAa,mBAAmB,oBAAoB,gBAAgB,EAAE;AAC7G,aAAa,IAAI;AACjB;AACA;AACA,wCAAwC;AACxC,KAAK,OAAO,iEAAU,GAAG;AACzB,KAAK,OAAO,+DAAQ,GAAG;AACvB,KAAK,OAAO,4EAAW,GAAG;AAC1B,KAAK,OAAO,yFAAiB,GAAG;AAChC,EAAE;AACF;AACA,qBAAqB,OAAO,4DAAK,uBAAuB;AACxD,iBAAiB,OAAO,4DAAK,EAAE;AAC/B,+BAA+B,OAAO,4DAAK,EAAE;AAC7C,eAAe,OAAO,4DAAK,EAAE;AAC7B,eAAe,OAAO,4DAAK,EAAE;AAC7B,gBAAgB,OAAO,4DAAK,EAAE;AAC9B,iBAAiB,OAAO,4DA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","file":"14.js","sourcesContent":["import { NgModule } from '@angular/core';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { IonicPageModule } from 'ionic-angular';\nimport { IonicImageLoader } from 'ionic-image-loader';\nimport { DirectivesModule } from '../../directives/directives.module';\n\nimport { PlantsPage } from './plants';\n\n@NgModule({\n  declarations: [\n    PlantsPage,\n  ],\n  imports: [\n    IonicPageModule.forChild(PlantsPage),\n    TranslateModule.forChild(),\n    IonicImageLoader,\n    DirectivesModule\n  ],\n  exports: [\n    PlantsPage\n  ]\n})\nexport class PlantsPageModule { }\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/plants/plants.module.ts","import { Injectable } from '@angular/core';\r\nvar ImageLoaderConfig = (function () {\r\n    function ImageLoaderConfig() {\r\n        this.debugMode = false;\r\n        this.spinnerEnabled = true;\r\n        this.fallbackAsPlaceholder = false;\r\n        this.backgroundSize = 'contain';\r\n        this.backgroundRepeat = 'no-repeat';\r\n        this.display = 'block';\r\n        this.width = '100%';\r\n        this.height = '100%';\r\n        this.useImg = false;\r\n        this.concurrency = 5;\r\n        this.maxCacheSize = -1;\r\n        this.maxCacheAge = -1;\r\n        this.imageReturnType = 'uri';\r\n        this.fileNameCachedWithExtension = false;\r\n        this.fallbackFileNameCachedExtension = '.jpg';\r\n        this._cacheDirectoryName = 'image-loader-cache';\r\n    }\r\n    Object.defineProperty(ImageLoaderConfig.prototype, \"cacheDirectoryName\", {\r\n        get: function () {\r\n            return this._cacheDirectoryName;\r\n        },\r\n        set: function (name) {\r\n            name.replace(/\\W/g, '');\r\n            this._cacheDirectoryName = name;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Enables debug mode to receive console logs, errors, warnings\r\n     */\r\n    ImageLoaderConfig.prototype.enableDebugMode = function () {\r\n        this.debugMode = true;\r\n    };\r\n    /**\r\n     * Enable/Disable the spinner by default. Defaults to true.\r\n     * @param enable {boolean} set to true to enable\r\n     */\r\n    ImageLoaderConfig.prototype.enableSpinner = function (enable) {\r\n        this.spinnerEnabled = enable;\r\n    };\r\n    /**\r\n     * Enable/Disable the fallback image as placeholder instead of the spinner. Defaults to false.\r\n     * @param enable {boolean} set to true to enable\r\n     */\r\n    ImageLoaderConfig.prototype.enableFallbackAsPlaceholder = function (enable) {\r\n        this.fallbackAsPlaceholder = enable;\r\n    };\r\n    /**\r\n     * Sets the cache directory name. Defaults to 'image-loader-cache'\r\n     * @param name {string} name of directory\r\n     */\r\n    ImageLoaderConfig.prototype.setCacheDirectoryName = function (name) {\r\n        this.cacheDirectoryName = name;\r\n    };\r\n    /**\r\n     * Set default height for images that are not using <img> tag\r\n     * @param height {string} height\r\n     */\r\n    ImageLoaderConfig.prototype.setHeight = function (height) {\r\n        this.height = height;\r\n    };\r\n    /**\r\n     * Set default width for images that are not using <img> tag\r\n     * @param width {string} Width\r\n     */\r\n    ImageLoaderConfig.prototype.setWidth = function (width) {\r\n        this.width = width;\r\n    };\r\n    /**\r\n     * Enable display mode for images that are not using <img> tag\r\n     * @param display {string} Display mode\r\n     */\r\n    ImageLoaderConfig.prototype.setDisplay = function (display) {\r\n        this.display = display;\r\n    };\r\n    /**\r\n     * Use <img> tag by default\r\n     * @param use {boolean} set to true to use <img> tag by default\r\n     */\r\n    ImageLoaderConfig.prototype.useImageTag = function (use) {\r\n        this.useImg = use;\r\n    };\r\n    /**\r\n     * Set default background size for images that are not using <img> tag\r\n     * @param backgroundSize {string} Background size\r\n     */\r\n    ImageLoaderConfig.prototype.setBackgroundSize = function (backgroundSize) {\r\n        this.backgroundSize = backgroundSize;\r\n    };\r\n    /**\r\n     * Set background repeat for images that are not using <img> tag\r\n     * @param backgroundRepeat {string} Background repeat\r\n     */\r\n    ImageLoaderConfig.prototype.setBackgroundRepeat = function (backgroundRepeat) {\r\n        this.backgroundRepeat = backgroundRepeat;\r\n    };\r\n    /**\r\n     * Set fallback URL to use when image src is undefined or did not resolve.\r\n     * This image will not be cached. This should ideally be a locally saved image.\r\n     * @param fallbackUrl {string} The remote or local URL of the image\r\n     */\r\n    ImageLoaderConfig.prototype.setFallbackUrl = function (fallbackUrl) {\r\n        this.fallbackUrl = fallbackUrl;\r\n    };\r\n    /**\r\n     * Set the maximum number of allowed connections at the same time.\r\n     * @param concurrency\r\n     */\r\n    ImageLoaderConfig.prototype.setConcurrency = function (concurrency) {\r\n        this.concurrency = concurrency;\r\n    };\r\n    /**\r\n     * Sets the maximum allowed cache size\r\n     * @param cacheSize {number} Cache size in bytes\r\n     */\r\n    ImageLoaderConfig.prototype.setMaximumCacheSize = function (cacheSize) {\r\n        this.maxCacheSize = cacheSize;\r\n    };\r\n    /**\r\n     * Sets the maximum allowed cache age\r\n     * @param cacheAge {number} Maximum cache age in milliseconds\r\n     */\r\n    ImageLoaderConfig.prototype.setMaximumCacheAge = function (cacheAge) {\r\n        this.maxCacheAge = cacheAge;\r\n    };\r\n    /**\r\n     * Set the return type of cached images\r\n     * @param imageReturnType {string} The return type; either 'base64' or 'uri'\r\n     */\r\n    ImageLoaderConfig.prototype.setImageReturnType = function (imageReturnType) {\r\n        this.imageReturnType = imageReturnType;\r\n    };\r\n    /**\r\n     * Set the default spinnern ame\r\n     * @param name\r\n     */\r\n    ImageLoaderConfig.prototype.setSpinnerName = function (name) {\r\n        this.spinnerName = name;\r\n    };\r\n    /**\r\n     * Set the default spinner color\r\n     * @param color\r\n     */\r\n    ImageLoaderConfig.prototype.setSpinnerColor = function (color) {\r\n        this.spinnerColor = color;\r\n    };\r\n    /**\r\n     * Set headers options for the HttpClient transfers.\r\n     * @param headers\r\n     */\r\n    ImageLoaderConfig.prototype.setHttpHeaders = function (headers) {\r\n        this.httpHeaders = headers;\r\n    };\r\n    /**\r\n     * Set options for the FileTransfer plugin\r\n     * @param options\r\n     * @deprecated FileTransfer plugin removed.\r\n     */\r\n    ImageLoaderConfig.prototype.setFileTransferOptions = function (options) {\r\n        // do nothing, plugin deprecated.\r\n    };\r\n    /**\r\n     * Enable/Disable the save filename of cached images with extension.  Defaults to false.\r\n     * @param enable {boolean} set to true to enable\r\n     */\r\n    ImageLoaderConfig.prototype.setFileNameCachedWithExtension = function (enable) {\r\n        this.fileNameCachedWithExtension = enable;\r\n    };\r\n    /**\r\n     * Set fallback extension filename of cached images.  Defaults to '.jpg'.\r\n     * @param extension {string} fallback extension (e.x .jpg)\r\n     */\r\n    ImageLoaderConfig.prototype.setFallbackFileNameCachedExtension = function (extension) {\r\n        this.fallbackFileNameCachedExtension = extension;\r\n    };\r\n    return ImageLoaderConfig;\r\n}());\r\nexport { ImageLoaderConfig };\r\nImageLoaderConfig.decorators = [\r\n    { type: Injectable },\r\n];\r\n/** @nocollapse */\r\nImageLoaderConfig.ctorParameters = function () { return []; };\r\n//# sourceMappingURL=image-loader-config.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ionic-image-loader/dist/providers/image-loader-config.js\n// module id = 553\n// module chunks = 0 14","import { Injectable } from '@angular/core';\r\nimport { File } from '@ionic-native/file';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { normalizeURL, Platform } from 'ionic-angular';\r\nimport { ImageLoaderConfig } from './image-loader-config';\r\nimport { Observable } from 'rxjs/Observable';\r\nimport 'rxjs/add/operator/first';\r\nvar ImageLoader = (function () {\r\n    function ImageLoader(config, file, http, platform) {\r\n        var _this = this;\r\n        this.config = config;\r\n        this.file = file;\r\n        this.http = http;\r\n        this.platform = platform;\r\n        /**\r\n         * Indicates if the cache service is ready.\r\n         * When the cache service isn't ready, images are loaded via browser instead.\r\n         * @type {boolean}\r\n         */\r\n        this.isCacheReady = false;\r\n        /**\r\n         * Indicates if this service is initialized.\r\n         * This service is initialized once all the setup is done.\r\n         * @type {boolean}\r\n         */\r\n        this.isInit = false;\r\n        /**\r\n         * Number of concurrent requests allowed\r\n         * @type {number}\r\n         */\r\n        this.concurrency = 5;\r\n        /**\r\n         * Queue items\r\n         * @type {Array}\r\n         */\r\n        this.queue = [];\r\n        this.processing = 0;\r\n        /**\r\n         * Fast accessable Object for currently processing items\r\n         */\r\n        this.currentlyProcessing = {};\r\n        this.cacheIndex = [];\r\n        this.currentCacheSize = 0;\r\n        this.indexed = false;\r\n        if (!platform.is('cordova')) {\r\n            // we are running on a browser, or using livereload\r\n            // plugin will not function in this case\r\n            this.isInit = true;\r\n            this.throwWarning('You are running on a browser or using livereload, IonicImageLoader will not function, falling back to browser loading.');\r\n        }\r\n        else {\r\n            Observable.fromEvent(document, 'deviceready').first().subscribe(function (res) {\r\n                if (_this.nativeAvailable) {\r\n                    _this.initCache();\r\n                }\r\n                else {\r\n                    // we are running on a browser, or using livereload\r\n                    // plugin will not function in this case\r\n                    _this.isInit = true;\r\n                    _this.throwWarning('You are running on a browser or using livereload, IonicImageLoader will not function, falling back to browser loading.');\r\n                }\r\n            });\r\n        }\r\n    }\r\n    Object.defineProperty(ImageLoader.prototype, \"nativeAvailable\", {\r\n        get: function () {\r\n            return File.installed();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ImageLoader.prototype, \"isCacheSpaceExceeded\", {\r\n        get: function () {\r\n            return this.config.maxCacheSize > -1 && this.currentCacheSize > this.config.maxCacheSize;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ImageLoader.prototype, \"isWKWebView\", {\r\n        get: function () {\r\n            return this.platform.is('ios') && window.webkit && window.webkit.messageHandlers;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ImageLoader.prototype, \"isIonicWKWebView\", {\r\n        get: function () {\r\n            return this.isWKWebView && (location.host === 'localhost:8080' || window.LiveReload);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ImageLoader.prototype, \"isDevServer\", {\r\n        get: function () {\r\n            return (window['IonicDevServer'] != undefined);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ImageLoader.prototype, \"canProcess\", {\r\n        /**\r\n         * Check if we can process more items in the queue\r\n         * @returns {boolean}\r\n         */\r\n        get: function () {\r\n            return (this.queue.length > 0\r\n                && this.processing < this.concurrency);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Preload an image\r\n     * @param imageUrl {string} Image URL\r\n     * @returns {Promise<string>} returns a promise that resolves with the cached image URL\r\n     */\r\n    ImageLoader.prototype.preload = function (imageUrl) {\r\n        return this.getImagePath(imageUrl);\r\n    };\r\n    /**\r\n     * Clears the cache\r\n     */\r\n    ImageLoader.prototype.clearCache = function () {\r\n        var _this = this;\r\n        if (!this.platform.is('cordova'))\r\n            return;\r\n        var clear = function () {\r\n            if (!_this.isInit) {\r\n                // do not run this method until our service is initialized\r\n                setTimeout(clear.bind(_this), 500);\r\n                return;\r\n            }\r\n            // pause any operations\r\n            _this.isInit = false;\r\n            _this.file.removeRecursively(_this.file.cacheDirectory, _this.config.cacheDirectoryName)\r\n                .then(function () {\r\n                if (_this.isWKWebView && !_this.isIonicWKWebView) {\r\n                    // also clear the temp files\r\n                    _this.file.removeRecursively(_this.file.tempDirectory, _this.config.cacheDirectoryName)\r\n                        .catch(function (error) {\r\n                        // Noop catch. Removing the tempDirectory might fail,\r\n                        // as it is not persistent.\r\n                    })\r\n                        .then(function () {\r\n                        _this.initCache(true);\r\n                    });\r\n                }\r\n                else {\r\n                    _this.initCache(true);\r\n                }\r\n            })\r\n                .catch(_this.throwError.bind(_this));\r\n        };\r\n        clear();\r\n    };\r\n    /**\r\n     * Gets the filesystem path of an image.\r\n     * This will return the remote path if anything goes wrong or if the cache service isn't ready yet.\r\n     * @param imageUrl {string} The remote URL of the image\r\n     * @returns {Promise<string>} Returns a promise that will always resolve with an image URL\r\n     */\r\n    ImageLoader.prototype.getImagePath = function (imageUrl) {\r\n        var _this = this;\r\n        if (typeof imageUrl !== 'string' || imageUrl.length <= 0) {\r\n            return Promise.reject('The image url provided was empty or invalid.');\r\n        }\r\n        return new Promise(function (resolve, reject) {\r\n            var getImage = function () {\r\n                if (_this.isImageUrlRelative(imageUrl)) {\r\n                    resolve(imageUrl);\r\n                }\r\n                else {\r\n                    _this.getCachedImagePath(imageUrl)\r\n                        .then(resolve)\r\n                        .catch(function () {\r\n                        // image doesn't exist in cache, lets fetch it and save it\r\n                        _this.addItemToQueue(imageUrl, resolve, reject);\r\n                    });\r\n                }\r\n            };\r\n            var check = function () {\r\n                if (_this.isInit) {\r\n                    if (_this.isCacheReady) {\r\n                        getImage();\r\n                    }\r\n                    else {\r\n                        _this.throwWarning('The cache system is not running. Images will be loaded by your browser instead.');\r\n                        resolve(imageUrl);\r\n                    }\r\n                }\r\n                else {\r\n                    setTimeout(function () { return check(); }, 250);\r\n                }\r\n            };\r\n            check();\r\n        });\r\n    };\r\n    /**\r\n     * Returns if an imageUrl is an relative path\r\n     * @param imageUrl\r\n     */\r\n    ImageLoader.prototype.isImageUrlRelative = function (imageUrl) {\r\n        return !/^(https?|file):\\/\\/\\/?/i.test(imageUrl);\r\n    };\r\n    /**\r\n     * Add an item to the queue\r\n     * @param imageUrl\r\n     * @param resolve\r\n     * @param reject\r\n     */\r\n    ImageLoader.prototype.addItemToQueue = function (imageUrl, resolve, reject) {\r\n        this.queue.push({\r\n            imageUrl: imageUrl,\r\n            resolve: resolve,\r\n            reject: reject\r\n        });\r\n        this.processQueue();\r\n    };\r\n    /**\r\n     * Processes one item from the queue\r\n     */\r\n    ImageLoader.prototype.processQueue = function () {\r\n        var _this = this;\r\n        // make sure we can process items first\r\n        if (!this.canProcess)\r\n            return;\r\n        // increase the processing number\r\n        this.processing++;\r\n        // take the first item from queue\r\n        var currentItem = this.queue.splice(0, 1)[0];\r\n        if (this.currentlyProcessing[currentItem.imageUrl] === undefined) {\r\n            this.currentlyProcessing[currentItem.imageUrl] = new Promise(function (resolve, reject) {\r\n                // process more items concurrently if we can\r\n                if (_this.canProcess)\r\n                    _this.processQueue();\r\n                // function to call when done processing this item\r\n                // this will reduce the processing number\r\n                // then will execute this function again to process any remaining items\r\n                var done = function () {\r\n                    _this.processing--;\r\n                    _this.processQueue();\r\n                    if (_this.currentlyProcessing[currentItem.imageUrl] !== undefined) {\r\n                        delete _this.currentlyProcessing[currentItem.imageUrl];\r\n                    }\r\n                };\r\n                var error = function (e) {\r\n                    currentItem.reject();\r\n                    _this.throwError(e);\r\n                    done();\r\n                };\r\n                var localDir = _this.file.cacheDirectory + _this.config.cacheDirectoryName + '/';\r\n                var fileName = _this.createFileName(currentItem.imageUrl);\r\n                _this.http.get(currentItem.imageUrl, {\r\n                    responseType: 'blob',\r\n                    headers: _this.config.httpHeaders\r\n                }).subscribe(function (data) {\r\n                    _this.file.writeFile(localDir, fileName, data, { replace: true }).then(function (file) {\r\n                        if (_this.isCacheSpaceExceeded) {\r\n                            _this.maintainCacheSize();\r\n                        }\r\n                        _this.addFileToIndex(file).then(function () {\r\n                            _this.getCachedImagePath(currentItem.imageUrl).then(function (localUrl) {\r\n                                currentItem.resolve(localUrl);\r\n                                resolve();\r\n                                done();\r\n                                _this.maintainCacheSize();\r\n                            });\r\n                        });\r\n                    }).catch(function (e) {\r\n                        //Could not write image\r\n                        error(e);\r\n                    });\r\n                }, function (e) {\r\n                    //Could not get image via httpClient\r\n                    error(e);\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            //Prevented same Image from loading at the same time\r\n            this.currentlyProcessing[currentItem.imageUrl].then(function () {\r\n                _this.getCachedImagePath(currentItem.imageUrl).then(function (localUrl) {\r\n                    currentItem.resolve(localUrl);\r\n                });\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Initialize the cache service\r\n     * @param replace {boolean} Whether to replace the cache directory if it already exists\r\n     */\r\n    ImageLoader.prototype.initCache = function (replace) {\r\n        var _this = this;\r\n        this.concurrency = this.config.concurrency;\r\n        // create cache directories if they do not exist\r\n        this.createCacheDirectory(replace)\r\n            .catch(function (e) {\r\n            _this.throwError(e);\r\n            _this.isInit = true;\r\n        })\r\n            .then(function () { return _this.indexCache(); })\r\n            .then(function () {\r\n            _this.isCacheReady = true;\r\n            _this.isInit = true;\r\n        });\r\n    };\r\n    /**\r\n     * Adds a file to index.\r\n     * Also deletes any files if they are older than the set maximum cache age.\r\n     * @param file {FileEntry} File to index\r\n     * @returns {Promise<any>}\r\n     */\r\n    ImageLoader.prototype.addFileToIndex = function (file) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) { return file.getMetadata(resolve, reject); })\r\n            .then(function (metadata) {\r\n            if (_this.config.maxCacheAge > -1\r\n                && (Date.now() - metadata.modificationTime.getTime()) > _this.config.maxCacheAge) {\r\n                // file age exceeds maximum cache age\r\n                return _this.removeFile(file.name);\r\n            }\r\n            else {\r\n                // file age doesn't exceed maximum cache age, or maximum cache age isn't set\r\n                _this.currentCacheSize += metadata.size;\r\n                // add item to index\r\n                _this.cacheIndex.push({\r\n                    name: file.name,\r\n                    modificationTime: metadata.modificationTime,\r\n                    size: metadata.size\r\n                });\r\n                return Promise.resolve();\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Indexes the cache if necessary\r\n     * @returns {any}\r\n     */\r\n    ImageLoader.prototype.indexCache = function () {\r\n        var _this = this;\r\n        this.cacheIndex = [];\r\n        return this.file.listDir(this.file.cacheDirectory, this.config.cacheDirectoryName)\r\n            .then(function (files) { return Promise.all(files.map(_this.addFileToIndex.bind(_this))); })\r\n            .then(function () {\r\n            // Sort items by date. Most recent to oldest.\r\n            _this.cacheIndex = _this.cacheIndex.sort(function (a, b) { return a > b ? -1 : a < b ? 1 : 0; });\r\n            _this.indexed = true;\r\n            return Promise.resolve();\r\n        })\r\n            .catch(function (e) {\r\n            _this.throwError(e);\r\n            return Promise.resolve();\r\n        });\r\n    };\r\n    /**\r\n     * This method runs every time a new file is added.\r\n     * It checks the cache size and ensures that it doesn't exceed the maximum cache size set in the config.\r\n     * If the limit is reached, it will delete old images to create free space.\r\n     */\r\n    ImageLoader.prototype.maintainCacheSize = function () {\r\n        var _this = this;\r\n        if (this.config.maxCacheSize > -1 && this.indexed) {\r\n            var maintain_1 = function () {\r\n                if (_this.currentCacheSize > _this.config.maxCacheSize) {\r\n                    // called when item is done processing\r\n                    var next_1 = function () {\r\n                        _this.currentCacheSize -= file_1.size;\r\n                        maintain_1();\r\n                    };\r\n                    // grab the first item in index since it's the oldest one\r\n                    var file_1 = _this.cacheIndex.splice(0, 1)[0];\r\n                    if (typeof file_1 == 'undefined')\r\n                        return maintain_1();\r\n                    // delete the file then process next file if necessary\r\n                    _this.removeFile(file_1.name)\r\n                        .then(function () { return next_1(); })\r\n                        .catch(function () { return next_1(); }); // ignore errors, nothing we can do about it\r\n                }\r\n            };\r\n            maintain_1();\r\n        }\r\n    };\r\n    /**\r\n     * Remove a file\r\n     * @param file {string} The name of the file to remove\r\n     */\r\n    ImageLoader.prototype.removeFile = function (file) {\r\n        var _this = this;\r\n        return this.file\r\n            .removeFile(this.file.cacheDirectory + this.config.cacheDirectoryName, file)\r\n            .then(function () {\r\n            if (_this.isWKWebView && !_this.isIonicWKWebView) {\r\n                return _this.file\r\n                    .removeFile(_this.file.tempDirectory + _this.config.cacheDirectoryName, file)\r\n                    .catch(function () {\r\n                    // Noop catch. Removing the files from tempDirectory might fail, as it is not persistent.\r\n                });\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Get the local path of a previously cached image if exists\r\n     * @param url {string} The remote URL of the image\r\n     * @returns {Promise<string>} Returns a promise that resolves with the local path if exists, or rejects if doesn't exist\r\n     */\r\n    ImageLoader.prototype.getCachedImagePath = function (url) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            // make sure cache is ready\r\n            if (!_this.isCacheReady) {\r\n                return reject();\r\n            }\r\n            // if we're running with livereload, ignore cache and call the resource from it's URL\r\n            if (_this.isDevServer) {\r\n                return resolve(url);\r\n            }\r\n            // get file name\r\n            var fileName = _this.createFileName(url);\r\n            // get full path\r\n            var dirPath = _this.file.cacheDirectory + _this.config.cacheDirectoryName, tempDirPath = _this.file.tempDirectory + _this.config.cacheDirectoryName;\r\n            // check if exists\r\n            _this.file.resolveLocalFilesystemUrl(dirPath + '/' + fileName)\r\n                .then(function (fileEntry) {\r\n                // file exists in cache\r\n                if (_this.config.imageReturnType === 'base64') {\r\n                    // read the file as data url and return the base64 string.\r\n                    // should always be successful as the existence of the file\r\n                    // is alreay ensured\r\n                    _this.file\r\n                        .readAsDataURL(dirPath, fileName)\r\n                        .then(function (base64) {\r\n                        base64 = base64.replace('data:null', 'data:*/*');\r\n                        resolve(base64);\r\n                    })\r\n                        .catch(reject);\r\n                }\r\n                else if (_this.config.imageReturnType === 'uri') {\r\n                    // now check if iOS device & using WKWebView Engine.\r\n                    // in this case only the tempDirectory is accessible,\r\n                    // therefore the file needs to be copied into that directory first!\r\n                    if (_this.isIonicWKWebView) {\r\n                        // Use Ionic normalizeUrl to generate the right URL for Ionic WKWebView\r\n                        resolve(normalizeURL(fileEntry.nativeURL));\r\n                    }\r\n                    else if (_this.isWKWebView) {\r\n                        // check if file already exists in temp directory\r\n                        _this.file.resolveLocalFilesystemUrl(tempDirPath + '/' + fileName)\r\n                            .then(function (tempFileEntry) {\r\n                            // file exists in temp directory\r\n                            // return native path\r\n                            resolve(tempFileEntry.nativeURL);\r\n                        })\r\n                            .catch(function () {\r\n                            // file does not yet exist in the temp directory.\r\n                            // copy it!\r\n                            _this.file.copyFile(dirPath, fileName, tempDirPath, fileName)\r\n                                .then(function (tempFileEntry) {\r\n                                // now the file exists in the temp directory\r\n                                // return native path\r\n                                resolve(tempFileEntry.nativeURL);\r\n                            })\r\n                                .catch(reject);\r\n                        });\r\n                    }\r\n                    else {\r\n                        // return native path\r\n                        resolve(fileEntry.nativeURL);\r\n                    }\r\n                }\r\n            })\r\n                .catch(reject); // file doesn't exist\r\n        });\r\n    };\r\n    /**\r\n     * Throws a console error if debug mode is enabled\r\n     * @param args {any[]} Error message\r\n     */\r\n    ImageLoader.prototype.throwError = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (this.config.debugMode) {\r\n            args.unshift('ImageLoader Error: ');\r\n            console.error.apply(console, args);\r\n        }\r\n    };\r\n    /**\r\n     * Throws a console warning if debug mode is enabled\r\n     * @param args {any[]} Error message\r\n     */\r\n    ImageLoader.prototype.throwWarning = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (this.config.debugMode) {\r\n            args.unshift('ImageLoader Warning: ');\r\n            console.warn.apply(console, args);\r\n        }\r\n    };\r\n    /**\r\n     * Check if the cache directory exists\r\n     * @param directory {string} The directory to check. Either this.file.tempDirectory or this.file.cacheDirectory\r\n     * @returns {Promise<boolean|FileError>} Returns a promise that resolves if exists, and rejects if it doesn't\r\n     */\r\n    ImageLoader.prototype.cacheDirectoryExists = function (directory) {\r\n        return this.file.checkDir(directory, this.config.cacheDirectoryName);\r\n    };\r\n    /**\r\n     * Create the cache directories\r\n     * @param replace {boolean} override directory if exists\r\n     * @returns {Promise<DirectoryEntry|FileError>} Returns a promise that resolves if the directories were created, and rejects on error\r\n     */\r\n    ImageLoader.prototype.createCacheDirectory = function (replace) {\r\n        var _this = this;\r\n        if (replace === void 0) { replace = false; }\r\n        var cacheDirectoryPromise, tempDirectoryPromise;\r\n        if (replace) {\r\n            // create or replace the cache directory\r\n            cacheDirectoryPromise = this.file.createDir(this.file.cacheDirectory, this.config.cacheDirectoryName, replace);\r\n        }\r\n        else {\r\n            // check if the cache directory exists.\r\n            // if it does not exist create it!\r\n            cacheDirectoryPromise = this.cacheDirectoryExists(this.file.cacheDirectory)\r\n                .catch(function () { return _this.file.createDir(_this.file.cacheDirectory, _this.config.cacheDirectoryName, false); });\r\n        }\r\n        if (this.isWKWebView && !this.isIonicWKWebView) {\r\n            if (replace) {\r\n                // create or replace the temp directory\r\n                tempDirectoryPromise = this.file.createDir(this.file.tempDirectory, this.config.cacheDirectoryName, replace);\r\n            }\r\n            else {\r\n                // check if the temp directory exists.\r\n                // if it does not exist create it!\r\n                tempDirectoryPromise = this.cacheDirectoryExists(this.file.tempDirectory)\r\n                    .catch(function () { return _this.file.createDir(_this.file.tempDirectory, _this.config.cacheDirectoryName, false); });\r\n            }\r\n        }\r\n        else {\r\n            tempDirectoryPromise = Promise.resolve();\r\n        }\r\n        return Promise.all([cacheDirectoryPromise, tempDirectoryPromise]);\r\n    };\r\n    /**\r\n     * Creates a unique file name out of the URL\r\n     * @param url {string} URL of the file\r\n     * @returns {string} Unique file name\r\n     */\r\n    ImageLoader.prototype.createFileName = function (url) {\r\n        // hash the url to get a unique file name\r\n        return this.hashString(url).toString() + (this.config.fileNameCachedWithExtension ? this.getExtensionFromFileName(url) : '');\r\n    };\r\n    /**\r\n     * Converts a string to a unique 32-bit int\r\n     * @param string {string} string to hash\r\n     * @returns {number} 32-bit int\r\n     */\r\n    ImageLoader.prototype.hashString = function (string) {\r\n        var hash = 0, char;\r\n        if (string.length === 0)\r\n            return hash;\r\n        for (var i = 0; i < string.length; i++) {\r\n            char = string.charCodeAt(i);\r\n            hash = ((hash << 5) - hash) + char;\r\n            hash = hash & hash;\r\n        }\r\n        return hash;\r\n    };\r\n    /**\r\n     * extract extension from filename or url\r\n     *\r\n     * @param filename\r\n     * @returns {string}\r\n     */\r\n    ImageLoader.prototype.getExtensionFromFileName = function (filename) {\r\n        return filename.substr((~-filename.lastIndexOf('.') >>> 0) + 1) || this.config.fallbackFileNameCachedExtension;\r\n    };\r\n    return ImageLoader;\r\n}());\r\nexport { ImageLoader };\r\nImageLoader.decorators = [\r\n    { type: Injectable },\r\n];\r\n/** @nocollapse */\r\nImageLoader.ctorParameters = function () { return [\r\n    { type: ImageLoaderConfig, },\r\n    { type: File, },\r\n    { type: HttpClient, },\r\n    { type: Platform, },\r\n]; };\r\n//# sourceMappingURL=image-loader.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ionic-image-loader/dist/providers/image-loader.js\n// module id = 557\n// module chunks = 0 14","import { Component, ElementRef, EventEmitter, Input, Output, Renderer } from '@angular/core';\r\nimport { ImageLoader } from '../providers/image-loader';\r\nimport { ImageLoaderConfig } from '../providers/image-loader-config';\r\nvar propMap = {\r\n    display: 'display',\r\n    height: 'height',\r\n    width: 'width',\r\n    backgroundSize: 'background-size',\r\n    backgroundRepeat: 'background-repeat'\r\n};\r\nvar ImgLoader = (function () {\r\n    function ImgLoader(_element, _renderer, _imageLoader, _config) {\r\n        this._element = _element;\r\n        this._renderer = _renderer;\r\n        this._imageLoader = _imageLoader;\r\n        this._config = _config;\r\n        /**\r\n         * Fallback URL to load when the image url fails to load or does not exist.\r\n         */\r\n        this.fallbackUrl = this._config.fallbackUrl;\r\n        /**\r\n         * Whether to show a spinner while the image loads\r\n         */\r\n        this.spinner = this._config.spinnerEnabled;\r\n        /**\r\n         * Whether to show the fallback image instead of a spinner while the image loads\r\n         */\r\n        this.fallbackAsPlaceholder = this._config.fallbackAsPlaceholder;\r\n        /**\r\n         * Enable/Disable caching\r\n         * @type {boolean}\r\n         */\r\n        this.cache = true;\r\n        /**\r\n         * Width of the image. This will be ignored if using useImg.\r\n         */\r\n        this.width = this._config.width;\r\n        /**\r\n         * Height of the image. This will be ignored if using useImg.\r\n         */\r\n        this.height = this._config.height;\r\n        /**\r\n         * Display type of the image. This will be ignored if using useImg.\r\n         */\r\n        this.display = this._config.display;\r\n        /**\r\n         * Background size. This will be ignored if using useImg.\r\n         */\r\n        this.backgroundSize = this._config.backgroundSize;\r\n        /**\r\n         * Background repeat. This will be ignored if using useImg.\r\n         */\r\n        this.backgroundRepeat = this._config.backgroundRepeat;\r\n        /**\r\n         * Name of the spinner\r\n         */\r\n        this.spinnerName = this._config.spinnerName;\r\n        /**\r\n         * Color of the spinner\r\n         */\r\n        this.spinnerColor = this._config.spinnerColor;\r\n        /**\r\n         * Notify on image load..\r\n         */\r\n        this.load = new EventEmitter();\r\n        /**\r\n         * Indicates if the image is still loading\r\n         * @type {boolean}\r\n         */\r\n        this.isLoading = true;\r\n        this._useImg = this._config.useImg;\r\n    }\r\n    Object.defineProperty(ImgLoader.prototype, \"src\", {\r\n        get: function () {\r\n            return this._src;\r\n        },\r\n        /**\r\n         * The URL of the image to load.\r\n         */\r\n        set: function (imageUrl) {\r\n            this._src = this.processImageUrl(imageUrl);\r\n            this.updateImage(this._src);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ;\r\n    Object.defineProperty(ImgLoader.prototype, \"useImg\", {\r\n        /**\r\n         * Use <img> tag\r\n         */\r\n        set: function (val) {\r\n            this._useImg = val !== false;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ImgLoader.prototype, \"noCache\", {\r\n        /**\r\n         * Convenience attribute to disable caching\r\n         * @param val\r\n         */\r\n        set: function (val) {\r\n            this.cache = val !== false;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ImgLoader.prototype.ngOnInit = function () {\r\n        if (this.fallbackAsPlaceholder && this.fallbackUrl) {\r\n            this.setImage(this.fallbackUrl, false);\r\n        }\r\n        if (!this.src) {\r\n            // image url was not passed\r\n            // this can happen when [src] is set to a variable that turned out to be undefined\r\n            // one example could be a list of users with their profile pictures\r\n            // in this case, it would be useful to use the fallback image instead\r\n            // if fallbackUrl was used as placeholder we do not need to set it again\r\n            if (!this.fallbackAsPlaceholder && this.fallbackUrl) {\r\n                // we're not going to cache the fallback image since it should be locally saved\r\n                this.setImage(this.fallbackUrl);\r\n            }\r\n            else {\r\n                this.isLoading = false;\r\n            }\r\n        }\r\n    };\r\n    ImgLoader.prototype.updateImage = function (imageUrl) {\r\n        var _this = this;\r\n        this._imageLoader.getImagePath(imageUrl)\r\n            .then(function (imageUrl) { return _this.setImage(imageUrl); })\r\n            .catch(function (error) { return _this.setImage(_this.fallbackUrl || imageUrl); });\r\n    };\r\n    /**\r\n     * Gets the image URL to be loaded and disables caching if necessary\r\n     * @returns {string}\r\n     */\r\n    ImgLoader.prototype.processImageUrl = function (imageUrl) {\r\n        if (this.cache === false) {\r\n            // need to disable caching\r\n            if (imageUrl.indexOf('?') === -1) {\r\n                imageUrl += '?';\r\n            }\r\n            if (['&', '?'].indexOf(imageUrl.charAt(imageUrl.length)) === -1) {\r\n                imageUrl += '&';\r\n            }\r\n            // append timestamp at the end to make URL unique\r\n            imageUrl += 'cache_buster=' + Date.now();\r\n        }\r\n        return imageUrl;\r\n    };\r\n    /**\r\n     * Set the image to be displayed\r\n     * @param imageUrl {string} image src\r\n     * @param stopLoading {boolean} set to true to mark the image as loaded\r\n     */\r\n    ImgLoader.prototype.setImage = function (imageUrl, stopLoading) {\r\n        var _this = this;\r\n        if (stopLoading === void 0) { stopLoading = true; }\r\n        this.isLoading = !stopLoading;\r\n        if (this._useImg) {\r\n            // Using <img> tag\r\n            if (!this.element) {\r\n                // create img element if we dont have one\r\n                this.element = this._renderer.createElement(this._element.nativeElement, 'img');\r\n            }\r\n            // set it's src\r\n            this._renderer.setElementAttribute(this.element, 'src', imageUrl);\r\n            if (this.fallbackUrl && !this._imageLoader.nativeAvailable) {\r\n                this._renderer.listen(this.element, 'error', function () { return _this._renderer.setElementAttribute(_this.element, 'src', _this.fallbackUrl); });\r\n            }\r\n        }\r\n        else {\r\n            // Not using <img> tag\r\n            this.element = this._element.nativeElement;\r\n            for (var prop in propMap) {\r\n                if (this[prop]) {\r\n                    this._renderer.setElementStyle(this.element, propMap[prop], this[prop]);\r\n                }\r\n            }\r\n            this._renderer.setElementStyle(this.element, 'background-image', 'url(\\'' + (imageUrl || this.fallbackUrl) + '\\')');\r\n        }\r\n        this.load.emit(this);\r\n    };\r\n    return ImgLoader;\r\n}());\r\nexport { ImgLoader };\r\nImgLoader.decorators = [\r\n    { type: Component, args: [{\r\n                selector: 'img-loader',\r\n                template: '<ion-spinner *ngIf=\"spinner && isLoading && !fallbackAsPlaceholder\" [name]=\"spinnerName\" [color]=\"spinnerColor\"></ion-spinner>' +\r\n                    '<ng-content></ng-content>',\r\n                styles: ['ion-spinner { float: none; margin-left: auto; margin-right: auto; display: block; }']\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nImgLoader.ctorParameters = function () { return [\r\n    { type: ElementRef, },\r\n    { type: Renderer, },\r\n    { type: ImageLoader, },\r\n    { type: ImageLoaderConfig, },\r\n]; };\r\nImgLoader.propDecorators = {\r\n    'fallbackUrl': [{ type: Input, args: ['fallback',] },],\r\n    'spinner': [{ type: Input },],\r\n    'fallbackAsPlaceholder': [{ type: Input },],\r\n    'cache': [{ type: Input },],\r\n    'width': [{ type: Input },],\r\n    'height': [{ type: Input },],\r\n    'display': [{ type: Input },],\r\n    'backgroundSize': [{ type: Input },],\r\n    'backgroundRepeat': [{ type: Input },],\r\n    'spinnerName': [{ type: Input },],\r\n    'spinnerColor': [{ type: Input },],\r\n    'load': [{ type: Output },],\r\n    'src': [{ type: Input },],\r\n    'useImg': [{ type: Input },],\r\n    'noCache': [{ type: Input },],\r\n};\r\n//# sourceMappingURL=img-loader.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ionic-image-loader/dist/components/img-loader.js\n// module id = 558\n// module chunks = 0 14","export * from './image-loader.module';\r\nexport * from './components/img-loader';\r\nexport * from './providers/image-loader-config';\r\nexport * from './providers/image-loader';\r\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ionic-image-loader/dist/index.js\n// module id = 559\n// module chunks = 0 14","import { NgModule } from '@angular/core';\r\nimport { ImgLoader } from './components/img-loader';\r\nimport { ImageLoader } from './providers/image-loader';\r\nimport { ImageLoaderConfig } from './providers/image-loader-config';\r\nimport { IonicModule } from 'ionic-angular';\r\nimport { File } from '@ionic-native/file';\r\nimport { HttpClientModule } from '@angular/common/http';\r\nvar IonicImageLoader = (function () {\r\n    function IonicImageLoader() {\r\n    }\r\n    IonicImageLoader.forRoot = function () {\r\n        return {\r\n            ngModule: IonicImageLoader,\r\n            providers: [\r\n                ImageLoaderConfig,\r\n                ImageLoader,\r\n                File\r\n            ]\r\n        };\r\n    };\r\n    return IonicImageLoader;\r\n}());\r\nexport { IonicImageLoader };\r\nIonicImageLoader.decorators = [\r\n    { type: NgModule, args: [{\r\n                declarations: [\r\n                    ImgLoader\r\n                ],\r\n                imports: [\r\n                    IonicModule,\r\n                    HttpClientModule\r\n                ],\r\n                exports: [\r\n                    ImgLoader\r\n                ]\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nIonicImageLoader.ctorParameters = function () { return []; };\r\n//# sourceMappingURL=image-loader.module.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ionic-image-loader/dist/image-loader.module.js\n// module id = 560\n// module chunks = 0 14","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar first_1 = require('../../operator/first');\nObservable_1.Observable.prototype.first = first_1.first;\n//# sourceMappingURL=first.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/first.js\n// module id = 561\n// module chunks = 0 14","\"use strict\";\nvar first_1 = require('../operators/first');\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * <img src=\"./img/first.png\" width=\"100%\">\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * @example <caption>Emit only the first click that happens on the DOM</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Emits the first click that happens on a DIV</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {function(value: T, index: number): R} [resultSelector] A function to\n * produce the value on the output Observable based on the values\n * and the indices of the source Observable. The arguments passed to this\n * function are:\n * - `value`: the value that was emitted on the source.\n * - `index`: the \"index\" of the value from the source.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} An Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\nfunction first(predicate, resultSelector, defaultValue) {\n    return first_1.first(predicate, resultSelector, defaultValue)(this);\n}\nexports.first = first;\n//# sourceMappingURL=first.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/first.js\n// module id = 562\n// module chunks = 0 14","import { Component } from '@angular/core';\nimport { IonicPage, ModalController, NavController } from 'ionic-angular';\nimport { HttpClient } from '@angular/common/http';\n\nimport { Database, Api } from '../../providers';\n\n@IonicPage()\n@Component({\n  selector: 'page-plants',\n  templateUrl: 'plants.html'\n})\nexport class PlantsPage {\n  Object = Object;\n  filters;\n  plants;\n  morePlants = [];\n  searching;\n\n  constructor(public navCtrl: NavController, public database: Database, public api: Api, public modalCtrl: ModalController, public http: HttpClient) {\n       \n\n    this.filters = {\n      cycle: '',\n      stratum: '',\n    }\n\n    this.searching = false\n\n    this.list();\n    // this.populate();\n\n  }\n\n  list(name = '') {\n    \n    this.database.query('plant', name, this.filters).then(res => {\n      this.plants = res.sort(function(a, b){\n        if(a.name < b.name) { return -1; }\n        if(a.name > b.name) { return 1; }\n        return 0;\n      });\n\n      if (this.plants && this.plants.length > 10) {\n        this.morePlants = this.plants.slice(10, this.plants.length+1)\n        this.plants = this.plants.slice(0, 10)\n      }\n    })  \n  }\n\n  showMore(infiniteScroll) {\n    if (this.morePlants && this.morePlants.length > 0) {\n      this.plants = this.plants.concat(this.morePlants.slice(0, 5))            \n      this.morePlants = this.morePlants.slice(5, this.morePlants.length+1)\n    }\n    infiniteScroll.complete();\n\n  }\n\n  search(ev?) {\n    this.searching = true\n\n    let val = '';\n    if (ev) {\n      val = ev.target.value;\n    }\n    this.list(val);    \n  }\n\n  add() {\n    this.navCtrl.push('PlantFormPage');\n  } \n\n  open(id) {\n    this.navCtrl.push('PlantPage', {\n      id: id\n    });\n  }\n\n}\n\n\n// WEBPACK FOOTER //\n// ./src/pages/plants/plants.ts"],"sourceRoot":""}